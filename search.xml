<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Markdown常用命令</title>
    <url>/2022/09/03/Markdown%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="这是一篇用于测试的页面"><a href="#这是一篇用于测试的页面" class="headerlink" title="这是一篇用于测试的页面"></a>这是一篇用于测试的页面</h1><h1 id="2022-9-5"><a href="#2022-9-5" class="headerlink" title="2022.9.5"></a>2022.9.5</h1><p>今天想学习如何插入图片和代码表示：</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>查了一下是代码表示为<code>tab上面的那个</code></p>
<p>成功啦</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片为为<code>![名称](地址)</code>，试下：</p>
<p><img src="https://pbs.twimg.com/media/FdLE8ipagAAA1qP?format=jpg&amp;name=large" alt="图片测试"></p>
<p>成功啦！</p>
<h1 id="2022-9-6"><a href="#2022-9-6" class="headerlink" title="2022.9.6"></a>2022.9.6</h1><p>今天学习下如何使用LaTeX公式，代码和注释：</p>
<h2 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h2><p>如果有文章需要开启LaTeX，记得在开头加上<code>mathjax: ture</code></p>
<p>貌似和LaTeX没有什么变化，一个美元是文本中的公式，两个美元是换行单独一行的公式,不好意思这里没办法打符号给大家看，用了转义符也没有显示。</p>
<p>这里另外说一点，如果特殊符号转义只要在前面加<code>\</code>就可以了。</p>
<p>试一下写个欧拉公式：</p>
<script type="math/tex; mode=display">e^{i\pi }+1=0</script><p>成功啦！</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h3 id="方法1：用tab键直接实现："><a href="#方法1：用tab键直接实现：" class="headerlink" title="方法1：用tab键直接实现："></a>方法1：用<code>tab</code>键直接实现：</h3><p>测试一下：</p>
<pre><code>print&quot;hello world!&quot;
</code></pre><p>成功啦！</p>
<h3 id="方法2：用-包裹代码："><a href="#方法2：用-包裹代码：" class="headerlink" title="方法2：用```包裹代码："></a>方法2：用```包裹代码：</h3><p>测试一下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print&quot;hello world!&quot;</span><br></pre></td></tr></table></figure></p>
<p>成功啦！</p>
<h2 id="写注释"><a href="#写注释" class="headerlink" title="写注释"></a>写注释</h2><p>有几张方法，不过写一个最简单的就好了：<code>&lt;！--写注释--&gt;</code></p>
<p>测试一下：</p>
<!--写注释-->
<p>成功啦！哈哈哈当然你们看不到！</p>
<h1 id="2022-9-7"><a href="#2022-9-7" class="headerlink" title="2022.9.7"></a>2022.9.7</h1><p>今天试着插入图片，之前插入的图片来源于Twitter，我今天试试Baidu的和本地的，看下能不能成功：</p>
<h2 id="Baidu图片插入"><a href="#Baidu图片插入" class="headerlink" title="Baidu图片插入"></a>Baidu图片插入</h2><p>图片为为<code>![名称](地址)</code>，试下：</p>
<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.577865b6804b46b74fbd1f90c32ab050?rik=wyyAsnT8byDlHQ&amp;riu=http%3a%2f%2fwww.bkill.com%2fu%2fupload%2f2018%2f03%2f13%2f140123254153.jpg&amp;ehk=duhXRwn7iwcIknm%2bTohI3sS200c%2fEKqnxxx0TFJWFMU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="Baidu图片测试"></p>
<p>成功啦！</p>
<h2 id="本地图片插入"><a href="#本地图片插入" class="headerlink" title="本地图片插入"></a>本地图片插入</h2><p>1.试了下base64转码<a href="https://base64.us/">转码地址</a>这个是可以成功的，但是一大串代码放在我的md里面我看着非常难受，所以我试下用其他的方法；</p>
<p>2.直接把图片放在一个文件夹里试试：</p>
<p><img src="/images/0.jpg" alt="本地图片测试"> </p>
<p><img src="/images/1.png" alt="图片暂存"></p>
<p><strong>可以直接复制图片至文章中</strong></p>
<p>成功了！</p>
<h1 id="2022-9-8"><a href="#2022-9-8" class="headerlink" title="2022.9.8"></a>2022.9.8</h1><p>今天主要是弄了优化，实际上有些bug，无语了</p>
<h1 id="2022-9-10"><a href="#2022-9-10" class="headerlink" title="2022.9.10"></a>2022.9.10</h1><p>中秋节快乐！</p>
<p>昨天忘记记录了，不过也没干什么事情，出去玩了哈哈哈哈</p>
<p>今天美化了一下我的blog，好看多了哈哈哈哈</p>
<h2 id="置顶文章"><a href="#置顶文章" class="headerlink" title="置顶文章"></a>置顶文章</h2><p>如果需要对某篇文章进行置顶，只需要加入<code>sticky: 1</code>就可，详细可看<code>Myblog</code>已经置顶！</p>
<p>成功啦！</p>
<h2 id="给文章加封面"><a href="#给文章加封面" class="headerlink" title="给文章加封面"></a>给文章加封面</h2><p>在开头加入<code>cover: (图片地址)</code></p>
<p>成功啦！</p>
<h1 id="2023-3-27"><a href="#2023-3-27" class="headerlink" title="2023.3.27"></a>2023.3.27</h1><p>久违的更新，补充一下对文章的加密</p>
<h2 id="准备工作（我的已完成）"><a href="#准备工作（我的已完成）" class="headerlink" title="准备工作（我的已完成）"></a>准备工作（我的已完成）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure>
<h2 id="把代码放在文章顶部"><a href="#把代码放在文章顶部" class="headerlink" title="把代码放在文章顶部"></a>把代码放在文章顶部</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">password: test</span><br><span class="line">message: 测试加密，这里的密码是：test</span><br></pre></td></tr></table></figure>
<p>我以<a href="https://aurora7july.github.io/2022/10/25/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/">“量子力学”</a>这篇为例试验一下：</p>
<p>成功了！</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog学习</title>
    <url>/2023/09/19/Verilog%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>Verilog学习</strong></p>
<h2 id="verilog-HDL-层次化设计"><a href="#verilog-HDL-层次化设计" class="headerlink" title="verilog HDL 层次化设计"></a>verilog HDL 层次化设计</h2><h3 id="模块和端口"><a href="#模块和端口" class="headerlink" title="模块和端口"></a>模块和端口</h3><ol>
<li>模块=模块名定义+端口描述+内部功能逻辑</li>
<li>逻辑功能描述：变量声明、数据流描述语句、门级实例化描述语句、行为描述语句、任务与函数。</li>
<li>关键词：<code>module</code>定义模块名字；<code>input</code>、<code>output</code>指定端口方向；<code>endmodule</code>结束模块描述。</li>
<li>模块定义格式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 模块名</span><br><span class="line">端口定义</span><br><span class="line">......</span><br><span class="line">unmodule</span><br></pre></td></tr></table></figure></li>
<li>端口定义：有两种格式<ul>
<li>普通风格 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 模块名</span><br><span class="line">input [位宽-1: 0] 端口名1，端口名2  </span><br><span class="line">output [位宽-1: 0] 端口3 </span><br><span class="line">inout [位宽-1: 0]端口4</span><br></pre></td></tr></table></figure></li>
<li>ANSI C风格 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 模块名</span><br><span class="line">( input [位宽-1: 0] 端口名1，端口名2  </span><br><span class="line">  output [位宽-1: 0] 端口3 </span><br><span class="line">  inout [位宽-1: 0]端口4</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>实例化：不允许嵌套，模块之间只能通过实例化</li>
</ol>
<h2 id="层次化设计思想"><a href="#层次化设计思想" class="headerlink" title="层次化设计思想"></a>层次化设计思想</h2><ul>
<li>自顶向下<br>类似于根据一张图纸造物</li>
<li>自底向上<br>类似于根据材料造物，可以是已知也可以是未知的</li>
</ul>
<h2 id="Testbench概念"><a href="#Testbench概念" class="headerlink" title="Testbench概念"></a>Testbench概念</h2><p>用于测试设计的电路的功能是否正常</p>
<h2 id="verilog-HDL基本语法"><a href="#verilog-HDL基本语法" class="headerlink" title="verilog HDL基本语法"></a>verilog HDL基本语法</h2><h3 id="词法约定"><a href="#词法约定" class="headerlink" title="词法约定"></a>词法约定</h3><ol>
<li>空白符：空格<code>\b</code>，制表<code>\t</code>和换行</li>
<li>注释：单行<code>//</code>，多行<code>*/.../*</code>(不允许嵌套)</li>
<li>操作符：单目操作符<code>~</code>，双目操作符<code>+</code>，三目操作符<code>?</code></li>
<li>标识符：<ul>
<li>第一个字符是字母或下划线</li>
<li>区分大小写</li>
<li>转义<code>\</code></li>
<li>空白符结束</li>
</ul>
</li>
<li>关键字：均为小写<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3>— 线网：除<code>tri</code>和<code>reg</code>所有网线类型不能存储数据值<br>— 变量：抽象的数据存储单元</li>
<li>逻辑值与常量</li>
</ol>
<ul>
<li>基本值：0/1真假，x未知，z高阻(不分大小写)</li>
<li>整数：二进制、十进制、十六进制、八进制  <pre><code>   格式：`[位宽]&#39;[进制][数值]`  
   负数：加负号
</code></pre></li>
<li>实数：十进制和科学计数法(可用e或E表示)</li>
</ul>
<ol>
<li>逻辑强度：supply最强，highz最弱</li>
</ol>
<ul>
<li>线网类型：<code>wire</code>和<code>tri</code>最常见<br> 格式：<code>wire [7:0] datain, dataoutt</code>(*两个8位的wire数据)【这是举例】</li>
<li>变量类型：<code>reg</code>类型、<code>integer</code>型、<code>real</code>型、<code>time</code>型</li>
<li>向量：位宽大于1</li>
<li>数组：数组中的每一个元素可以是标量也可以是向量</li>
<li>参数：<code>defparam语句</code>(同样不可嵌套)  </li>
</ul>
<ol>
<li>表达式</li>
</ol>
<ul>
<li>操作数</li>
<li>算术操作符：单双目操作数。单目<code>+ -</code>表正负，双目<code>* / + -</code>运算符号</li>
<li>逻辑操作符：逻辑与<code>&amp;&amp;</code>，逻辑或<code>||</code>，逻辑非<code>!</code></li>
<li>关系操作符：<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code></li>
<li>相等操作符：逻辑相等<code>==</code>，逻辑不等<code>!=</code>，逻辑全等<code>===</code>，逻辑非全等<code>!==</code></li>
<li>按位操作符：反<code>~</code>，与<code>&amp;</code>，或<code>|</code>，异或<code>^</code>，同或<code>^~, ~^</code></li>
<li>缩减操作符：缩减与<code>&amp;</code>，缩减与非<code>-&amp;</code>，缩减或<code>|</code>，缩减或非<code>~|</code>，缩减异或<code>^</code>，缩减同或<code>~^, ^~</code></li>
<li>位移操作：右移<code>&gt;&gt;</code>，左移<code>&lt;&lt;</code>，算术左移<code>&lt;&lt;&lt;</code>，算术右移<code>&gt;&gt;&gt;</code></li>
<li>拼接操作符：格式<code>&#123;操作1，操作2，操作3，...，操作n&#125;</code></li>
<li>条件操作符：根据条件表达式的值从两个表达式中选择一个表达式作为输出结果，格式<code>条件表达式? 真表达式 ： 假表达式</code></li>
</ul>
<h2 id="Verilog-HDL行为描述"><a href="#Verilog-HDL行为描述" class="headerlink" title="Verilog HDL行为描述"></a>Verilog HDL行为描述</h2><h3 id="Verilog-HDL基本描述形式"><a href="#Verilog-HDL基本描述形式" class="headerlink" title="Verilog HDL基本描述形式"></a>Verilog HDL基本描述形式</h3><ol>
<li>数据流描述方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assing [延迟] wire类型 = 表达式</span><br></pre></td></tr></table></figure></li>
<li>行为描述方式<br>两种语句：initial和always<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">always @(事件控制列表) begin</span><br><span class="line">···</span><br><span class="line">end</span><br><span class="line">或</span><br><span class="line">intial begin</span><br><span class="line">···</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>层次化描述方式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块名 实例名</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="结构化过程语句"><a href="#结构化过程语句" class="headerlink" title="结构化过程语句"></a>结构化过程语句</h3><p><strong>initial和always语句不能相互嵌套使用</strong></p>
<ol>
<li>initial语句<br>从仿真的0时刻开始，只执行一次。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg a, b, c; //initial中只有一条赋值语句</span><br><span class="line">initial</span><br><span class="line">   a = 1&#x27;b0; </span><br><span class="line">//若含多条赋值语句，需要begin end</span><br><span class="line">initial begin</span><br><span class="line">   b = 1&#x27;b0;</span><br><span class="line">   c = 1&#x27;b0;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>always语句<br>从仿真的0时刻开始，会重新执行命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg a;</span><br><span class="line">initial a = 0;</span><br><span class="line">always #50 a =-a;</span><br><span class="line">//从0开始，每隔50个时间单位的反复操作</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="顺序块和并行块"><a href="#顺序块和并行块" class="headerlink" title="顺序块和并行块"></a>顺序块和并行块</h3><ol>
<li>顺序块：按书写顺讯依次执行</li>
<li>并行块：<code>fork</code>是同时开始</li>
<li>块语句的其他特点<ul>
<li>嵌套块</li>
<li>命名块</li>
</ul>
</li>
</ol>
<h3 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h3><ol>
<li>阻塞赋值语句<br>用<code>=</code>作为赋值符，按顺序执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg a, b;</span><br><span class="line">initial begin</span><br><span class="line">   a = 1&#x27;b0; </span><br><span class="line">   b = 1&#x27;b0;</span><br><span class="line">   #10 a = 1&#x27;b1; //阻塞赋值语句对a赋新值，a变为1后才继续执行后面的命令</span><br><span class="line">       b = a;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>非阻塞赋值语句<br>用<code>&lt;=</code>作为赋值符，不会阻塞同一个块语句中的其他语句的执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg a, b;</span><br><span class="line">initial begin</span><br><span class="line">   a = 1&#x27;b0;</span><br><span class="line">   b = 1&#x27;b0;</span><br><span class="line">   #10 a &lt;= 1&#x27;b1; //用非阻塞赋值语句赋值，赋值还未完成先完成后面的语句</span><br><span class="line">       b &lt;= a; //由于a的赋值未完成，所以b的值还是0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>有三种情况，<code>if</code>表达式，<code>if-else</code>表达式，<code>if-else if</code>表达式。<br><em>注意</em>，这里容易弄混，一定要搞清楚。</p>
<h3 id="多路分支语句"><a href="#多路分支语句" class="headerlink" title="多路分支语句"></a>多路分支语句</h3><p>当分支特别多时，<code>if</code> <code>else</code>语句非常不好用，就可以使用<code>case</code>语句<br><code>case</code>语句的关键词：<code>case</code> <code>default</code> <code>endcase</code> 格式如下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case(表达式)</span><br><span class="line">   分支表达式1: 语句1</span><br><span class="line">   分支表达式2: 语句2</span><br><span class="line">   ···</span><br><span class="line">   default: 默认语句</span><br><span class="line">   endcase</span><br></pre></td></tr></table></figure></p>
<h3 id="条件语句和多路分支语句的比较"><a href="#条件语句和多路分支语句的比较" class="headerlink" title="条件语句和多路分支语句的比较"></a>条件语句和多路分支语句的比较</h3><p><code>if...else</code>语句有优先级，而<code>case</code>语句没有，是并行的关系。</p>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><ol>
<li>while循环<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(条件表达式)</span><br><span class="line">   语句：</span><br></pre></td></tr></table></figure>
当表示式为真时，则循环执行里面的雨具；如果为假，中止循环并跳出while。如果while中表达式的值为x或z时，当作假处理。</li>
<li>for循环<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(循环变量初值;循环结束条件;循环变量增值)</span><br></pre></td></tr></table></figure>
在for中，C语言有i++，而verilog没有，改成i=i+1</li>
<li>repeat循环<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat(循环次数表达式)</span><br></pre></td></tr></table></figure></li>
<li>forever循环</li>
</ol>
<h3 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h3><ol>
<li>延迟控制<br>分为常规和内嵌，两者区别为：常规是整个语句执行后，在推迟的时间后，赋值语句开始计算；内嵌是开始执行时刻就立即计算表达式右边的值，此值会一直保持至延迟结束。</li>
</ol>
<ul>
<li>常规延迟<br><code># [延迟值] 语句</code></li>
<li>内嵌延迟<br><code>语句 #[延迟值]</code></li>
</ul>
<ol>
<li>事件控制<br>发生某个事件(变量、线网信号或表达式的值发生变化)之后，整个逻辑发生变化</li>
</ol>
<ul>
<li>边沿敏感事件控制<br>用边缘敏感符号<code>@</code>，格式为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ 事件</span><br><span class="line">    语句;</span><br></pre></td></tr></table></figure>
这里有个<strong>关键字:posedge(上升沿跳变)/negedge(下降沿跳变)</strong> 记住即可<br>如果出现了多个敏感事件，则用<code>or</code>或者<code>,</code>即可</li>
<li>电平敏感事件控制<br>以信号值变化的边沿为标志的，即一定要达到指定信号的某个值的变化边沿才会触发执行，关键字为<code>wait</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait(事件) 语句;</span><br></pre></td></tr></table></figure>
当事件为真时，后面的语句才会执行</li>
<li>时序控制语句在综合代码中的应用<br>在进行电路综合时，延迟控制语句会被综合工具自动忽略，当作无延迟处理</li>
</ul>
<h2 id="组合逻辑建模"><a href="#组合逻辑建模" class="headerlink" title="组合逻辑建模"></a>组合逻辑建模</h2><h3 id="数字电路建模方式"><a href="#数字电路建模方式" class="headerlink" title="数字电路建模方式"></a>数字电路建模方式</h3><p>电路与代码的一一对应关系</p>
<h3 id="组合逻辑的门级描述"><a href="#组合逻辑的门级描述" class="headerlink" title="组合逻辑的门级描述"></a>组合逻辑的门级描述</h3><p>与门(and)、与非门(nand)、或门(or)、或非门(nor)、异或门(xor)、同或门(xnor)、缓冲器(buf)、非门(not)、三台缓冲器控制信号低电平有效(bufif0)、三台缓冲器控制信号高电平有效(bufif1)、三态非门控制信号低电平有效(notif0)、三态非门控制信号高电平有效(notif1)</p>
<h3 id="组合逻辑的数据流描述"><a href="#组合逻辑的数据流描述" class="headerlink" title="组合逻辑的数据流描述"></a>组合逻辑的数据流描述</h3><ol>
<li>连续赋值语句<br><code>assign[延迟]wire型变量=表达式;</code></li>
</ol>
<ol>
<li>数据流描述<br>利用数据流描述可以很方便的描述一个加法器等，用符号就可以了，比如<code>+</code> <code>*</code>等</li>
</ol>
<h3 id="组合逻辑的行为描述"><a href="#组合逻辑的行为描述" class="headerlink" title="组合逻辑的行为描述"></a>组合逻辑的行为描述</h3><h3 id="组合逻辑建模实例"><a href="#组合逻辑建模实例" class="headerlink" title="组合逻辑建模实例"></a>组合逻辑建模实例</h3><ol>
<li>比较器</li>
<li>译码器和编码器</li>
</ol>
<h2 id="时序逻辑电路"><a href="#时序逻辑电路" class="headerlink" title="时序逻辑电路"></a>时序逻辑电路</h2><h3 id="时序逻辑建模概述"><a href="#时序逻辑建模概述" class="headerlink" title="时序逻辑建模概述"></a>时序逻辑建模概述</h3><p>时序逻辑电路指的是在verilog HDL所描述的电路中，包含一个或多个存储单元。这些存储单元可以是边沿触发的寄存器，或者是电平触发的锁存器。由于引入了存储单元，时序逻辑电路具有了“记忆”功能，可以记录当前时刻之前的输入激励情况及电路状态。</p>
<h3 id="寄存器和锁存器设计"><a href="#寄存器和锁存器设计" class="headerlink" title="寄存器和锁存器设计"></a>寄存器和锁存器设计</h3><ol>
<li>寄存器实例<br>在<code>always</code>后面的敏感列表中加入边沿敏感的信号，即可设计出一个简单的寄存器。<code>posedge</code>是在时钟的上升沿触发并采集数据端口的值；<code>negedge</code>则在下降沿触发。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module dff</span><br><span class="line">(</span><br><span class="line">   input i_clk,</span><br><span class="line">   input i_din,</span><br><span class="line">   output reg o_dout</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(posedge i_clk) //在always语句的敏感列表@()中加入边沿敏感的时钟信号i_clk</span><br><span class="line">  o_dout &lt;= i_din;</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<ol>
<li>锁存器的设计实例<br>用verilog描述一个的锁存器，该锁存器在控制信号i_en为高电平时开启，为低电平时锁存器当前值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module latch</span><br><span class="line">(</span><br><span class="line">   input i_en,</span><br><span class="line">   input i_din,</span><br><span class="line">   output reg o_dout</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always@(i_den or i_en) //敏感列表中没有边沿触发的信号</span><br><span class="line">  if(i_en)</span><br><span class="line">    o_dout &lt;= i_din;</span><br><span class="line"></span><br><span class="line">endmodule </span><br></pre></td></tr></table></figure>
<h3 id="寄存器和锁存器的推断"><a href="#寄存器和锁存器的推断" class="headerlink" title="寄存器和锁存器的推断"></a>寄存器和锁存器的推断</h3></li>
<li>寄存器的推断</li>
</ol>
<ul>
<li>寄存器是一种时序元件，用于存储数据，并且在时钟信号的上升沿或下降沿触发时更新数据。</li>
<li>寄存器在时钟边沿触发时，将其输入数据传递到输出，具有确定的时序行为。</li>
<li>在Verilog中，通常使用触发器（Flip-Flops）来实现寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//举例说明</span><br><span class="line">module DFF (</span><br><span class="line">    input wire D,    // 数据输入</span><br><span class="line">    input wire CLK,  // 时钟信号</span><br><span class="line">    output wire Q    // 数据输出</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">always @(posedge CLK) begin</span><br><span class="line">    Q &lt;= D;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>锁存器的推断</li>
</ol>
<ul>
<li>锁存器是一种组合逻辑元件，它不需要时钟信号，而是根据输入信号的变化实时更新输出。</li>
<li>锁存器不是时序元件，通常应该避免在数字电路中使用锁存器，因为它们可能会导致不稳定的行为和时序问题。</li>
<li>锁存器可能会导致冒险条件，因此在设计中应该谨慎使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//举例说明</span><br><span class="line">module SRLatch (</span><br><span class="line">    input wire S,  // 设置输入</span><br><span class="line">    input wire R,  // 复位输入</span><br><span class="line">    output wire Q  // 数据输出</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assign Q = S &amp; ~R;</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h3 id="存储器的设计与建模"><a href="#存储器的设计与建模" class="headerlink" title="存储器的设计与建模"></a>存储器的设计与建模</h3></li>
</ul>
<ol>
<li>ROM建模<br>ROM是只读存储器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//变量z以数组的方式描述了一个ROM</span><br><span class="line">//由于使用了inital语句，因此该代码只能适用于仿真，不能综合</span><br><span class="line">module rom_sim</span><br><span class="line">(</span><br><span class="line">   input [2:0] i_sel,</span><br><span class="line">   output [3:0] o_dat</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">   reg [3:0] rom [0:7]; //通过数组声明存储器变量</span><br><span class="line"></span><br><span class="line">      inital begin //利用inital语句为ROM赋值</span><br><span class="line">      rom[0] = 4&#x27;b1001;</span><br><span class="line">      rom[1] = 4&#x27;b1011;</span><br><span class="line">      rom[2] = 4&#x27;b0010;</span><br><span class="line">      rom[3] = 4&#x27;b0011;</span><br><span class="line">      rom[4] = 4&#x27;b1110;</span><br><span class="line">      rom[5] = 4&#x27;b0000;</span><br><span class="line">      rom[6] = 4&#x27;b0000;</span><br><span class="line">      rom[7] = 4&#x27;b0000;</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   assign o_dat = rom[i_sel];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li>
<li>RAM建模<br>一个电平变化触发的16位宽RAM模型通常是基于时序逻辑的，使用触发器来存储数据。以下是一个简单的电平变化触发的16位宽RAM模型示例，使用2个16位触发器作为存储元件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module LevelSensitiveRAM16 (</span><br><span class="line">    input wire [3:0] address,       // 4位地址输入</span><br><span class="line">    input wire [15:0] data_in,      // 16位数据输入</span><br><span class="line">    input wire write_enable,       // 写使能信号</span><br><span class="line">    input wire read_enable,        // 读使能信号</span><br><span class="line">    output wire [15:0] data_out    // 16位数据输出</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg [15:0] memory [0:15];  // 16个16位触发器，模拟RAM的存储单元</span><br><span class="line"></span><br><span class="line">always @(posedge write_enable or posedge read_enable) begin</span><br><span class="line">    if (write_enable) begin</span><br><span class="line">        // 写操作：将输入数据写入存储器指定地址</span><br><span class="line">        memory[address] &lt;= data_in;</span><br><span class="line">    end</span><br><span class="line">    if (read_enable) begin</span><br><span class="line">        // 读操作：从存储器指定地址读取数据</span><br><span class="line">        data_out &lt;= memory[address];</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure>
<h3 id="同步有限状态机"><a href="#同步有限状态机" class="headerlink" title="同步有限状态机"></a>同步有限状态机</h3>同步有限状态机（Synchronous Finite State Machine，SFSM）是一种在特定时钟信号下运行的状态机，其中状态的转换和输出的更新都与时钟信号同步。SFSM 包括状态寄存器、组合逻辑块以及时钟信号。</li>
</ol>
<p>以下是一个简单的 2 状态同步有限状态机的示例，其状态转换和输出更新是同步的：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module SynchronousFSM (</span><br><span class="line">    input wire clk,          // 时钟信号</span><br><span class="line">    input wire rst,          // 复位信号</span><br><span class="line">    output wire [1:0] state, // 2位状态输出</span><br><span class="line">    output wire output       // 输出信号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">reg [1:0] current_state;   // 当前状态寄存器</span><br><span class="line"></span><br><span class="line">always @(posedge clk or posedge rst) begin</span><br><span class="line">    if (rst) begin</span><br><span class="line">        // 复位操作</span><br><span class="line">        current_state &lt;= 2&#x27;b00;  // 将状态初始化为00</span><br><span class="line">    end else begin</span><br><span class="line">        // 状态转换逻辑</span><br><span class="line">        case (current_state)</span><br><span class="line">            2&#x27;b00: current_state &lt;= 2&#x27;b01;  // 从00转换到01</span><br><span class="line">            2&#x27;b01: current_state &lt;= 2&#x27;b10;  // 从01转换到10</span><br><span class="line">            2&#x27;b10: current_state &lt;= 2&#x27;b00;  // 从10转换到00</span><br><span class="line">        endcase</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">assign state = current_state;   // 输出当前状态</span><br><span class="line"></span><br><span class="line">always @(posedge clk) begin</span><br><span class="line">    // 输出逻辑</span><br><span class="line">    case (current_state)</span><br><span class="line">        2&#x27;b00: output &lt;= 1&#x27;b0;  // 当前状态为00时输出0</span><br><span class="line">        default: output &lt;= 1&#x27;b1;  // 其他状态时输出1</span><br><span class="line">    endcase</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h3 id="时序逻辑建模实例"><a href="#时序逻辑建模实例" class="headerlink" title="时序逻辑建模实例"></a>时序逻辑建模实例</h3><ol>
<li>计数器  </li>
<li>串并/并串转换器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module p2s(clk,en,rsy,pin,sout)；</span><br><span class="line">input clk,en,rst;</span><br><span class="line">input [7:0] pin;</span><br><span class="line">output sout;</span><br><span class="line">output end; #并转串传输结束</span><br><span class="line"></span><br><span class="line">reg[2:0] cnt;</span><br><span class="line">reg[7:0] data;</span><br><span class="line"></span><br><span class="line">always@(posedge clk or posedge rst)</span><br><span class="line">  if(rst)</span><br><span class="line">    sout &lt;= 1&#x27;b0;</span><br><span class="line">    cnt &lt;= 3&#x27;b0;</span><br><span class="line">  end</span><br><span class="line">  else if(en) begin</span><br><span class="line">    cnt &lt;= cnt+1&#x27;b1;</span><br><span class="line">    sout &lt;= data[0];</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">always@(posedge clk or posedge rst)</span><br><span class="line">  if(rst)</span><br><span class="line">    data &lt;= 8&#x27;b0;</span><br><span class="line">  else</span><br><span class="line">    if(cnt==3&#x27;b0)</span><br><span class="line">      data &lt;= pin;</span><br><span class="line">    else</span><br><span class="line">      data &lt;= &#123;1&#x27;b0,data[7:1]&#125;;</span><br><span class="line"></span><br><span class="line">always@(posedge clk or posedge rst)</span><br><span class="line">  if(rst)</span><br><span class="line">    end &lt;= 1&#x27;b0;</span><br><span class="line">  else</span><br><span class="line">    end &lt;= (cnt==3&#x27;b111);</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></li>
<li>时钟分频电路</li>
</ol>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>5.4<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 8bit(</span><br><span class="line">   input wire clk,</span><br><span class="line">   input wire rst,</span><br><span class="line">   input wire [7:0] data_in,</span><br><span class="line">   output wire [7:0] data_out</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">   reg [7:0] reg_data;</span><br><span class="line"></span><br><span class="line">   always @(nesedge clk or posedge rst)begin</span><br><span class="line">     if (rst) </span><br><span class="line">        reg_data &lt;= 8&#x27;b0;</span><br><span class="line">       else</span><br><span class="line">        reg_data &lt;= date_in;</span><br><span class="line">        end</span><br><span class="line">   end</span><br><span class="line"></span><br><span class="line">   assign data_out = reg_data;</span><br><span class="line"></span><br><span class="line">endmodule </span><br></pre></td></tr></table></figure><br>5.6<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 32_RAM(clk,wr,addr,rdata,wdata);</span><br><span class="line">   input clk,wr;</span><br><span class="line">   input [31:0] wdata;</span><br><span class="line">   input [14:0] addr;</span><br><span class="line">   output [31:0] rdata;</span><br><span class="line"></span><br><span class="line">   reg [31:0] ram[32767:0]</span><br><span class="line"></span><br><span class="line">   always@(posedge clk)</span><br><span class="line">      if(wr)</span><br><span class="line">         ramp[addr] &lt;= wdata;</span><br><span class="line">      else</span><br><span class="line"></span><br><span class="line">   assign rdata =ram [addr];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>5.7<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module 32_RAM(clk,wr,addr,data);</span><br><span class="line">   input clk,wr;</span><br><span class="line">   inout [31:0] wdata;</span><br><span class="line">   inout [14:0] addr;</span><br><span class="line"></span><br><span class="line">   reg [31:0] ram[32767:0]</span><br><span class="line"></span><br><span class="line">   always@(posedge clk)</span><br><span class="line">      if(wr)</span><br><span class="line">         ramp[addr] &lt;= wdata;</span><br><span class="line">      else</span><br><span class="line">         data ram[addr]</span><br><span class="line">   assign rdata =ram [addr];</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>5.11<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module fsm(clk,rst_n,sel.hready,write,burst,resp_ok)</span><br><span class="line">   input clk,rst_n,sel,hready,write,burst,resp_ok;</span><br><span class="line">   parameter Reset=3&#x27;b000;</span><br><span class="line">   parmeter Idle=3&#x27;b001;</span><br><span class="line">   parmeter Addr=3&#x27;b010;</span><br><span class="line">   parmeter Write=3&#x27;b011;</span><br><span class="line">   parmeter Read=3&#x27;b100;</span><br><span class="line">   parmeter BurstWrite=3&#x27;b101;</span><br><span class="line">   parmeter BurstRead=3&#x27;b110;</span><br><span class="line">   parmeter Resp=3&#x27;b111;</span><br><span class="line"></span><br><span class="line">   reg [2:0] next_state.current_state;</span><br><span class="line">   always@(posedge clk or negedge rst_n)</span><br><span class="line">      if(!rst_n)</span><br><span class="line">         current_state &lt;= Reset;</span><br><span class="line">      else</span><br><span class="line">         current_state &lt;= next_state;</span><br><span class="line"></span><br><span class="line">   always@(rst_n or sel or hready or wirte orburst or resp_ok)</span><br><span class="line">      case(current_state)</span><br><span class="line">         Reset: if(rst_n) next_state =Idle;</span><br><span class="line">         Idle: if(sel&amp;&amp;hready) next_state = Addr;</span><br><span class="line">         Addr: if(write&amp;&amp;burst) next_state = Burstread;</span><br><span class="line">            else if(!write&amp;&amp;burst) next_state = burstread;</span><br><span class="line">            else if(!write&amp;&amp;burst) next_state = Read;</span><br><span class="line">            else next_state = Write;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure><br>5.15</p>
<h2 id="行为级仿真模型建模"><a href="#行为级仿真模型建模" class="headerlink" title="行为级仿真模型建模"></a>行为级仿真模型建模</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>verilog提供的时序控制语句主要有3种：延迟控制语句，事件控制语句和条件等待语句。</p>
<h3 id="仿真时间和时序控制"><a href="#仿真时间和时序控制" class="headerlink" title="仿真时间和时序控制"></a>仿真时间和时序控制</h3><p>事件控制语句指利用语法@()进行描述，@后面的括号里包含需要的语句</p>
<h3 id="仿真模型建模实例"><a href="#仿真模型建模实例" class="headerlink" title="仿真模型建模实例"></a>仿真模型建模实例</h3><ol>
<li>时钟发生器</li>
<li>简单的仿真环境</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>人脸识别实战</title>
    <url>/2023/03/19/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="人脸识别实战"><a href="#人脸识别实战" class="headerlink" title="人脸识别实战"></a>人脸识别实战</h1><h2 id="人脸图片数据收集"><a href="#人脸图片数据收集" class="headerlink" title="人脸图片数据收集"></a>人脸图片数据收集</h2><h3 id="Olivetti-Faces人脸数据集"><a href="#Olivetti-Faces人脸数据集" class="headerlink" title="Olivetti Faces人脸数据集"></a>Olivetti Faces人脸数据集</h3><p>我以纽约大学提供的一个非常小的人脸数据集举例，每人的人脸图片为10张，清晰度还算不错，且图片为经过剪裁和对齐的灰度人脸图片，<a href="https://cs.nyu.edu/~roweis/data/olivettifaces.gif">下载网址</a></p>
<p>想要收集数据，我们首先要做的就是对每个人的人脸图片进行切分。代码实例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">data = cv2.imread(&quot;olivettifaces.jpg&quot;)</span><br><span class="line">#转换为灰度图像</span><br><span class="line">data = cv2.cvtColor(data, cv2.COLOR_BRG2GRAY)</span><br><span class="line">#将人脸图片提取为&#123;label:list&#125;形式</span><br><span class="line">faces = &#123;&#125;</span><br><span class="line">label = 0</span><br><span class="line">count = 1</span><br><span class="line">pic_list = []</span><br><span class="line">for row in range(20):</span><br><span class="line">    for column in range(20):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="LFW人脸数据集"><a href="#LFW人脸数据集" class="headerlink" title="LFW人脸数据集"></a>LFW人脸数据集</h3><p>由马萨诸塞大学提供，<a href="http://vis-www.cs.umass/edu/lfw/#download">LFW人脸数据集</a></p>
<h3 id="YouTube-Faces人脸数据集"><a href="#YouTube-Faces人脸数据集" class="headerlink" title="YouTube Faces人脸数据集"></a>YouTube Faces人脸数据集</h3><p>这个一般是用来做人脸对比的，该网站包含1595个不同的人，来自于3425个在YouTube上下载的视频，网址地址：<a href="http://www.cs.tau.ac.il/~wolf/ytfaces/index.html">YouTube Faces</a></p>
<h2 id="使用OpenCV的人脸检测"><a href="#使用OpenCV的人脸检测" class="headerlink" title="使用OpenCV的人脸检测"></a>使用OpenCV的人脸检测</h2><h3 id="OpenCV的安装"><a href="#OpenCV的安装" class="headerlink" title="OpenCV的安装"></a>OpenCV的安装</h3><p>在Python中直接用pip下载</p>
<pre><code>pip install opencv-python
</code></pre><p>如果是在anaconda环境中安装OpenCV，可以通过以下方法：</p>
<pre><code>conda install opencv
</code></pre><h3 id="OpenCV的检测"><a href="#OpenCV的检测" class="headerlink" title="OpenCV的检测"></a>OpenCV的检测</h3><pre><code>#查看引入OpenCV库时会不会报错
import cv2
#查看安装版本
cv2.__version__
</code></pre><h3 id="Haar级联分类器"><a href="#Haar级联分类器" class="headerlink" title="Haar级联分类器"></a>Haar级联分类器</h3><p>在此之前需要先下载两个训练好的<code>xml文件</code>，可以在GitHub中<a href="https://github.com/opencv/opencv/tree/master/data/haarcascades">下载</a>将下载的文件放到和运行脚本同一个文件就可以了。</p>
<p>如果你没有放对xml，就会出现以下错误提示：<code>errror:(-215)!......</code></p>
<p>获得训练好的模型之后，就可以根据这个模型进行人脸识别了，完整代码如下：</p>
<pre><code>import cv2
#创建人脸检测级联分类器对象实例
face_cascade = cv2.CascadeClassifier(&#39;haarcascade_frontalface_default.xml&#39;)
#或采用lbp特征进行检测
#face_cascade = cv2.CascadeClassifier(&#39;lbpcascade_frontalface.xml&#39;)
#创建人眼检测级联分类的实例
eye_cascade = cv2.CascadeClassifier(&#39;haarcascade_eye.xml&#39;)
#载入图片
img = cv2.imread(&#39;lena.jpg&#39;)
#图片颜色意义不大，灰度化处理即可
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
#调用级联分类器进行多尺度检测
faces = face_cascade.detectMultiScale(gray, 1.3, 5)
#遍历检测到的结果
for (x,y,w,h) in faces:
    #检测矩形框，颜色值的顺序为BGR，即矩阵的颜色为蓝色
    cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)
    #roi即region of interest, 意思是感兴趣的领域
    roi_gray = gray[y:y+h, x:x+w]
    roi_color = img[y:y+h, x:x+w]
    #在检测到的人脸区域内检测眼睛
    eyes = eye_cascade.detectMultiScale(roi_gray)
    for (ex,ey,ew,eh) in eyes:
        cv2.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(0,255,0),2)
#写出图片
cv2.imwrite(&#39;detected_face.jpg&#39;,img) 
</code></pre><h2 id="使用Dlib的人脸检测"><a href="#使用Dlib的人脸检测" class="headerlink" title="使用Dlib的人脸检测"></a>使用Dlib的人脸检测</h2><p>Dlib自带了基于Hog特征的人脸检测器，同时在较新版本的Dlib 中，也自带了基于最大边界对象检测器 (Maximum-Margin Object Detector，MMOD)的人脸检测方法。</p>
<h3 id="基于Hog-SVM的人脸检测"><a href="#基于Hog-SVM的人脸检测" class="headerlink" title="基于Hog-SVM的人脸检测"></a>基于Hog-SVM的人脸检测</h3><p>下面示范一下使用 Dlib 自带的 Hog-SVM 人脸检测器的使用方法:<br>    import dlib<br>    import cv2</p>
<pre><code>img = cv2 .imread(&#39;lena.jpg&#39;)

# 加载检测模型
hog_face_detector = dlib.get_frontal_face_detector()
faceRects = hog_face_detector(img，0)
for faceRect in faceRects:
    xl = faceRect.left ()
    y1 = faceRect.top()
    x2 = faceRect.right ()
    y2 = faceRect.bottom()
</code></pre><p>上述代码需要下载Dlib训练好的检测模型，<a href="htp://dlib. net/files/data/dlib_face_detector_training_data. tar. gz">官方地址</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemVerilog学习</title>
    <url>/2023/12/16/systemverilog%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="第I章-验证导论"><a href="#第I章-验证导论" class="headerlink" title="第I章 验证导论"></a>第I章 验证导论</h1><h2 id="基本测试平台的功能"><a href="#基本测试平台的功能" class="headerlink" title="基本测试平台的功能"></a>基本测试平台的功能</h2><p>测试平台的用途在于确定待测设计的正确性，包含以下步骤:<br>1.产生激励<br>2.把激励施加到DUT上<br>3.捕捉响应<br>4.检验正确性<br>5.对照整个验证目标测算进展情况</p>
<h1 id="第II章-数据类型"><a href="#第II章-数据类型" class="headerlink" title="第II章 数据类型"></a>第II章 数据类型</h1><h2 id="内建数据类型"><a href="#内建数据类型" class="headerlink" title="内建数据类型"></a>内建数据类型</h2><p>两种基本类型：变量和线网，各自都可以有四种取值：1,0,Z,X</p>
<h3 id="1-逻辑-logic-类型"><a href="#1-逻辑-logic-类型" class="headerlink" title="1.逻辑(logic)类型"></a>1.逻辑(logic)类型</h3><p>SystemVerilog对经典的reg数据类型进行改进，使得它除了作为一个变量以外，还可以被连续赋值、门单元和模块所驱动，这种改进的数据类型被称为logic。<br>任何使用线网的地方均可以使用logic，但要求logic不能有多个结构性的驱动<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//logic类型使用实例</span><br><span class="line">module logic(input logic);</span><br><span class="line">  parameter CYCLE=20;</span><br><span class="line">  logic q,q_1,d,clk,rst_1;</span><br><span class="line">  inital begin</span><br><span class="line">    clk=0;                           //过程赋值</span><br><span class="line">    forever # (CYCLE/2) clk=~clk;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  assign rst_1=~rst_h;               //连续赋值</span><br><span class="line">  not n1(q_1,q);                     //q_1被门驱动</span><br><span class="line">  my_dff d1(q,d,clk,rst_1);          //q被模块驱动</span><br><span class="line">endmodule</span><br></pre></td></tr></table></figure></p>
<h3 id="2-双状态数据类型"><a href="#2-双状态数据类型" class="headerlink" title="2.双状态数据类型"></a>2.双状态数据类型</h3>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>git学习</title>
    <url>/2023/12/16/git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="git学习-书"><a href="#git学习-书" class="headerlink" title="git学习(书)"></a>git学习(书)</h1><h2 id="第I章-git是什么"><a href="#第I章-git是什么" class="headerlink" title="第I章 git是什么"></a>第I章 git是什么</h2><h3 id="git能解决什么？"><a href="#git能解决什么？" class="headerlink" title="git能解决什么？"></a>git能解决什么？</h3><p>git，是版本管理系统(时光机)  </p>
<ul>
<li>可以回到过去的状态</li>
<li>对于同一个文件可以多人协助修改</li>
<li>能记录修改源代码的原因</li>
</ul>
<h3 id="作为交流场所的GitHub和Bitbucket"><a href="#作为交流场所的GitHub和Bitbucket" class="headerlink" title="作为交流场所的GitHub和Bitbucket"></a>作为交流场所的GitHub和Bitbucket</h3><ul>
<li>相互之间检查代码</li>
<li>讨论前端样式和功能的实现</li>
<li>共享设计前后过程，相互提意见</li>
</ul>
<h2 id="第II章-我独自学习"><a href="#第II章-我独自学习" class="headerlink" title="第II章 我独自学习"></a>第II章 我独自学习</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>下载SourceTree</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>正常操作</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><ol>
<li>添加一个TXT或是其他的，sourcetree都会感觉到</li>
<li>点击“暂存所有”</li>
<li>提交</li>
<li>继续积累历史记录(先暂存再提交)</li>
<li>记得添加注释</li>
</ol>
<h3 id="用checkout移动提交"><a href="#用checkout移动提交" class="headerlink" title="用checkout移动提交"></a>用checkout移动提交</h3><p>执行checkout可以让操作目录中的文件变成指定某个时刻文件的状态</p>
<h2 id="第III章-多人协作使用git"><a href="#第III章-多人协作使用git" class="headerlink" title="第III章 多人协作使用git"></a>第III章 多人协作使用git</h2><h3 id="复制练习用仓库"><a href="#复制练习用仓库" class="headerlink" title="复制练习用仓库"></a>复制练习用仓库</h3><p>怎么复制？1.复刻；2，克隆<br>一个是复制到GitHub上，一个是复制到本地上</p>
<ul>
<li>复刻：指复制他人公开的远程仓库到自己账号中</li>
<li>克隆：把远程仓库复制到本地</li>
</ul>
<h3 id="创建并行世界-分支"><a href="#创建并行世界-分支" class="headerlink" title="创建并行世界(分支)"></a>创建并行世界(分支)</h3><ul>
<li>分支是什么？<br>分支是一个指向提交对象可变指针。指针的意思就是“现在”</li>
<li>移动分支<br>可以用checkout来让自己移动到任意一次提交</li>
<li>master是什么？<br>最开始就存在的分支，就像河流的“干流”</li>
</ul>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>merge可以让分支进行合并</p>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>上传数据，推送</p>
<h3 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h3><p>想要下载并反映到本地仓库的时候就是拉取</p>
<h3 id="有冲突怎么办"><a href="#有冲突怎么办" class="headerlink" title="有冲突怎么办"></a>有冲突怎么办</h3><ul>
<li>冲突是什么？<br>在同一行代码在同一时间被不同的人修改时发生的状况</li>
</ul>
<h3 id="从拉取请求到合并"><a href="#从拉取请求到合并" class="headerlink" title="从拉取请求到合并"></a>从拉取请求到合并</h3><p>想把自己的代码同步到fork源仓库中，用拉取请求(pull request)</p>
<h1 id="git实践学习"><a href="#git实践学习" class="headerlink" title="git实践学习"></a>git实践学习</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><ol>
<li><code>git commit</code>是Git 仓库中的提交记录保存  </li>
<li><code>git branch 名字</code>是创建分支  </li>
<li><code>git checkout &lt;name&gt;</code>让我们在提交修改之前先切换到新的分支上  </li>
<li>如果你想创建一个新的分支同时切换到新创建的分支的话，可以通过<code>git checkout -b &lt;your-branch-name&gt;</code>来实现。</li>
<li>将两个分支合并到一起方法1：<code>git merge</code></li>
<li>将两个分支合并到一起方法2：<code>git rebase</code></li>
</ol>
<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2><ol>
<li><code>HEAD</code>是一个对当前所在分支的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</li>
<li><code>HEAD</code>总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变<code>HEAD</code>的指向开始的。</li>
<li>用<code>git log</code>来查查看提交记录的哈希值</li>
<li>操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的 parent 提交。</li>
<li><code>~&lt;num&gt;</code>一次后退num步</li>
<li>我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:<code>git branch -f main HEAD~3</code>。上面的命令会将 main 分支强制指向 HEAD 的第 3 级 parent 提交。</li>
<li><code>git reset</code>通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>半导体制造</title>
    <url>/2023/09/16/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%88%B6%E9%80%A0/</url>
    <content><![CDATA[<h1 id="半导体制造"><a href="#半导体制造" class="headerlink" title="半导体制造"></a>半导体制造</h1><p>半导体制程是被用于制造芯片，一种日常使用的电气和电子器件中集成电路的处理工艺。它是一系列照相和化学处理步骤，在其中电子电路逐渐形成在使用纯半导体材料制作的晶片上。硅是今天最常用的半导体材料，其他还有各种复合半导体材料。从一开始晶圆加工，到芯片封装测试，直到出货，通常需要6到8周，并且是在晶圆厂内完成。</p>
<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><p>这是我专业课最后期末复习的笔记，内容不是很多，都是知识点，也不是很难，只需要记住就可以了。如果在预览过程中发现有知识性错误请及时联系我修改！</p>
<p>若无法显示PDF，可以点击该链接下载<a href="https://github.com/Aurora7july/files/blob/main/%E7%AC%94%E8%AE%B0PDF/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%88%B6%E9%80%A0.pdf">半导体制造</a></p>


	<div class="row">
    <embed src="/pdf/半导体制造.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游-澳门</title>
    <url>/2023/09/29/%E6%97%85%E6%B8%B8-%E6%BE%B3%E9%97%A8/</url>
    <content><![CDATA[<h2 id="澳门之旅-II"><a href="#澳门之旅-II" class="headerlink" title="澳门之旅 II"></a>澳门之旅 II</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>写这篇post的时候已经是2023.10.8了，本来计划在国庆假期内写完，还是拖到了现在才想起来，接下来就要我凭印象记录了。<br>这次是受高中同学的请求，带其去澳门看看，正好假期有空，便欣然答应。<br>这是我第二次去澳门，上次一人独行，初次领略纸醉金迷和高雅浪漫，可惜时间有限加之体力不足，未见夜晚的澳门的灯红酒绿，颇有些遗憾。此次前往，也算了却我一个小小的心愿。<br>澳门是一座美丽的城市，拥挤与繁华，富裕与友善，是我对这座小城市的印象。这座不及浦东机场面积的小城，竟甚至能在2019年产生世界第二的人均GDP。接下来，我将回忆本次去澳门的所见所闻与君分享。</p>
<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h3><ul>
<li>过境准备<br>我们乘坐C7611与9:20到达珠海站，之后前往青茂口岸，路途换了20mop坐公车。青茂口岸在2021年9月8日才正式投入使用，这里人少，快捷，凉快，吸取上次在拱北口岸大排队的教训，我们很快通过了海关，正式踏入澳门境内。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/IMG_20230225_091702.jpg?raw=true" alt="珠海站"></li>
<li><p>澳门半岛<br>从口岸坐公车前往澳门亚美打利庇卢大马路市政署和议事亭前地并拍照留念<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/1.jpg?raw=true" alt="市政署与议事亭前地"> </p>
<p>之后前往大三巴及周边附近拍照留念<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/2.jpg?raw=true" alt="大三巴及周边"></p>
<p>新葡京及附近娱乐场拍照留念<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/3.jpg?raw=true" alt="新葡京及附近娱乐场"></p>
<p>在梳打冰室吃午餐<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/4.jpg?raw=true" alt="午餐"></p>
<p>吃饱喝足之后前往澳门冼星海大马路澳门回归贺礼陈列馆<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/5.jpg?raw=true" alt="澳门回归贺礼陈列馆"></p>
</li>
<li><p>路氹<br>伦敦人、巴黎人、威尼斯人逛逛<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/6.jpg?raw=true" alt="三人"></p>
<p>晚饭吃M记，吃太快没拍<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/7.jpg?raw=true" alt="晚饭"></p>
<p>夜晚的澳门<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/8.jpg?raw=true" alt="夜之城"></p>
</li>
<li>返航<br>结束旅程，乘坐发财车返回口岸<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/macau-II/9.jpg?raw=true" alt="回家"></li>
</ul>
<h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h3><p>很喜欢澳门，这里民风淳朴，风景怡人，物价吓人。未满21岁还不让我进赌场，不能一睹美女荷官芳容，可惜可惜。下次再来吧，澳门活动也多，可以来一场说走就走的旅行。</p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游-外伶仃岛</title>
    <url>/2023/11/04/%E6%97%85%E6%B8%B8-%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/</url>
    <content><![CDATA[<h2 id="外伶仃岛一日游"><a href="#外伶仃岛一日游" class="headerlink" title="外伶仃岛一日游"></a>外伶仃岛一日游</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自国庆假期以后，我便陷入了上课和学习的纠缠，生活中再也不如从前那般恣意。随着身心疲惫渐显，渴望一次宽慰身心、回归自然之旅渐生。因此，我迅速检查了周末的天气情况，立即预订了船票，最终期盼已久的日子终于到来，我难掩内心的喜悦。如今，结束了这次旅程，我迫不及待地开始写这篇文章。</p>
<h3 id="装备列表"><a href="#装备列表" class="headerlink" title="装备列表"></a>装备列表</h3><ul>
<li>穿着：登山帽、墨镜、短袖、运动长裤、运动鞋</li>
<li>军粮：三明治、布丁、一包吐司、巧克力、550ml水</li>
<li>拍摄：手机支架、长焦倍镜</li>
<li>其他：清凉油、身份证、交通卡、充电宝</li>
</ul>
<h3 id="徒步路线"><a href="#徒步路线" class="headerlink" title="徒步路线"></a>徒步路线</h3><p>早上9：40从香洲港码头出发，于11：00抵达外伶仃岛。环岛旅行的交通方式有两种：乘坐观光车和步行前往。为了全身心融入这座美丽的小岛，我选择了徒步旅行。下了船，匆匆拍了两张港口的照片给朋友们分享后，便立即出发。徒步路线大致如下：<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/797e81330c452747f69f76c4fecaab9.jpg?raw=true" alt="徒步路线"></p>
<h3 id="矿石湖"><a href="#矿石湖" class="headerlink" title="矿石湖"></a>矿石湖</h3><p>今日的外伶仃岛矿石湖，曾经矿石开挖地，因为人工开挖自然形成的矿坑，遗留的开挖痕迹和大小碎石，足以想象曾经的忙碌与辉煌。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_125242688.jpg?raw=true" alt="矿石湖"></p>
<h3 id="最美公路"><a href="#最美公路" class="headerlink" title="最美公路"></a>最美公路</h3><p>外伶仃岛本就是一座被遗世独立的小岛，远离珠海市区，靠近香港，我徒步抵达时恰为正午，人烟稀少，只有远处鸣笛声声的货轮、呼啸长空的客机以及自由翱翔的鸟类陪伴，好生惬意。这条被誉为“最美公路”的蜿蜒小道是通往山顶的必经之路，也是最佳欣赏海景的不二之路。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_130734561.jpg?raw=true" alt="最美公里"><br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_132421420.jpg?raw=true" alt="飞机"><br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_132503436.jpg?raw=true" alt="鸟群"></p>
<p>走在这条路上，是我人生最安静的时光。我不需要思考过去和未来，也不必担心现在，只是单纯的享受阳光和大海，很难用语言或是音乐来描述我当时的意境。我坐在高处，阳光毫不吝啬的洒向每片角落，望向远方海天一色的美景，波光粼粼的海面驶过满载的货轮，聆听汩汩的海浪声，老鹰在空中肆意盘旋。我无法停止对蓝天与大海的赞美，我生于斯，也希望死于斯，铭于斯，其魂气无不之也。他总是这样，海纳百川，包容我于所有不完美，接纳我于所有无痛呻吟，即使我没有带来鲜花与热血。在此，我可以同最原始的自己交流，我们不再探讨未来的经济、职业与社交，也不再欣赏音乐与哲学，只是静静地融入这里和倾听心脏平稳的跳动。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/IMG_20231104_160311.jpg?raw=true" alt="自在的独行"></p>
<h3 id="独爱海景"><a href="#独爱海景" class="headerlink" title="独爱海景"></a>独爱海景</h3><p>我独爱海景，世间任何景色都难比于他。他给予我宁静，让我甘愿表露真我；他给予我恐惧，让我理智直面暗潮汹涌；他给予我方向，让我以自己的意志抵达未知。在无数个夜晚，感受到自己浸泡在海水中，随着洋流飘荡，与鱼群为友，与浪花为帆，穿越七大洲八大洋，没有目的，也是所有的目的地。我独爱海景，我无法停止赞美你，请祝福远行的游子早日追寻到她的自由与爱，赞美大海！<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_140105678.jpg?raw=true" alt="海洋"><br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_151734162.jpg?raw=true" alt="海洋"><br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E5%A4%96%E4%BC%B6%E4%BB%83%E5%B2%9B/CRnall_20231104_151854646.jpg?raw=true" alt="海洋"></p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>Python每日练习</title>
    <url>/2023/11/01/Python%E6%AF%8F%E6%97%A5%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="2023-11-1练习"><a href="#2023-11-1练习" class="headerlink" title="2023.11.1练习"></a>2023.11.1练习</h1><h2 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h2><p>编写一个程序，要求用户输入一个正整数，然后计算该整数的阶乘并输出结果。阶乘是指将一个整数与小于它的所有正整数相乘的结果。例如，5的阶乘是5 <em> 4 </em> 3 <em> 2 </em> 1 = 120。</p>
<h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul>
<li>提示用户输入一个正整数。</li>
<li>检查用户输入是否是正整数，如果不是，显示错误消息并要求重新输入。</li>
<li>计算输入整数的阶乘。</li>
<li>输出计算结果。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#提示用户输入</span><br><span class="line">num = input(&quot;请阁下输入一个正整数：&quot;) </span><br><span class="line"></span><br><span class="line">#判断用户输入是否是正整数</span><br><span class="line">if num.isdigit(): </span><br><span class="line">   num = int(num)</span><br><span class="line">   if num &gt; 0:</span><br><span class="line">      print(f&quot;&#123;num&#125;是一个正整数&quot;)</span><br><span class="line">   else:</span><br><span class="line">      print(f&quot;&#123;num&#125;不是正整数，请阁下重新输入&quot;)</span><br><span class="line">else:</span><br><span class="line">   print(f&quot;&#123;num&#125;不是正整数，请阁下重新输入&quot;) </span><br><span class="line"></span><br><span class="line">#计算整数的阶乘</span><br><span class="line">result = 1</span><br><span class="line">for i in range(1, num+1):</span><br><span class="line">    result *= i</span><br><span class="line">print(f&quot;&#123;num&#125;的阶乘为:&#123;result&#125;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h2><p> 编写一个Python程序，要求用户输入一个字符串，然后判断这个字符串是否是回文字符串。回文字符串是指正着读和倒着读都一样的字符串，例如 “level”、”radar” 和 “madam” 都是回文字符串。</p>
<h2 id="要求：-1"><a href="#要求：-1" class="headerlink" title="要求："></a>要求：</h2><ul>
<li>提示用户输入一个字符串。</li>
<li>忽略字符串中的空格，标点符号和大小写（将所有字符转换为小写）。</li>
<li>判断输入的字符串是否是回文字符串。</li>
<li>输出相应的结果，指出是否是回文字符串。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">#提示用户输入</span><br><span class="line">user_input = input(&quot;请阁下输入一个字符串：&quot;)</span><br><span class="line"></span><br><span class="line">#移除空格，标点和大小写</span><br><span class="line">user_input = user_input.replace(&quot; &quot;, &quot;&quot;) #移除空格</span><br><span class="line">user_input = re.sub(r&#x27;[^\w\s]&#x27;,&#x27;&#x27;,user_input) #移除符号标点</span><br><span class="line">user_input = user_input.lower() #转换为小写</span><br><span class="line"></span><br><span class="line">#判断输入的字符是否是回文字符串</span><br><span class="line">fan_input = user_input[::-1] #创建反向字符串</span><br><span class="line">if fan_input == user_input: #判断是否是回文字符串</span><br><span class="line">    print(f&quot;恭喜阁下，&#123;user_input&#125;是回文字符串！&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;很抱歉，&#123;user_input&#125;并不是回文字符串&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2023-11-5练习"><a href="#2023-11-5练习" class="headerlink" title="2023.11.5练习"></a>2023.11.5练习</h1><h2 id="问题1：-1"><a href="#问题1：-1" class="headerlink" title="问题1："></a>问题1：</h2><p>写一个Python程序，找出一个列表中的所有奇数，并将它们存储在一个新的列表中。</p>
<h2 id="要求：-2"><a href="#要求：-2" class="headerlink" title="要求："></a>要求：</h2><ul>
<li>创建一个函数，该函数接受一个整数列表作为参数。</li>
<li>函数应该返回一个新的列表，其中包含原列表中的所有奇数。</li>
<li>不要使用内置的filter函数或列表解析来完成任务。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def find_odd_numbers(input_list): #定义奇数函数</span><br><span class="line">   odd_numbers = [] #形成一个列表</span><br><span class="line">   input_list = input_list.split(&quot;,&quot;) #对列表进行切片</span><br><span class="line">   input_list = [int(num.strip()) for num in input_list] #检查奇数</span><br><span class="line">   input_list = [int(num_str.strip()) for num_str in input_list]  # 更改变量名</span><br><span class="line"></span><br><span class="line">   for num in input_list: #遍历列表</span><br><span class="line">      if num % 2 != 0:</span><br><span class="line">         odd_numbers.append(num)</span><br><span class="line">         </span><br><span class="line">   return odd_numbers</span><br><span class="line"></span><br><span class="line">user_input = input(&quot;请阁下输入一串列表(用，隔开): &quot;)</span><br><span class="line">result = find_odd_numbers(user_input)</span><br><span class="line">print(&quot;奇数列表：&quot;, result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="问题2：-1"><a href="#问题2：-1" class="headerlink" title="问题2："></a>问题2：</h2><p>编写一个Python程序，计算斐波那契数列的第n个数字，其中n是非负整数。<br>斐波那契数列的定义如下：<br>1.第0个和第1个数字分别为0和1。<br>2.从第2个数字开始，每个数字都是前两个数字之和</p>
<h2 id="要求：-3"><a href="#要求：-3" class="headerlink" title="要求："></a>要求：</h2><ul>
<li>创建一个函数，接受一个非负整数n作为参数。</li>
<li>函数应该返回斐波那契数列的第n个数字。</li>
<li>请使用递归方式来解决这个问题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#定义斐波那契数列的函数</span><br><span class="line">def fibonacci(n):</span><br><span class="line">   if n &lt;= 0:</span><br><span class="line">      return 0</span><br><span class="line">   elif n == 1:</span><br><span class="line">      return 1</span><br><span class="line">   else:</span><br><span class="line">      return fibonacci(n-1) + fibonacci(n-2)</span><br><span class="line"></span><br><span class="line">#提示用户输入</span><br><span class="line">user_input = input(&quot;请阁下输入一个非负整数&quot;)</span><br><span class="line"></span><br><span class="line">#测试用户输入的是否是一个非负整数</span><br><span class="line">try:</span><br><span class="line">   user_input = int(user_input)</span><br><span class="line">   if user_input &lt; 0:</span><br><span class="line">    print(&quot;让你打非负整数你不听,你XX!&quot;)</span><br><span class="line">   else:</span><br><span class="line">    result =  fibonacci(user_input)</span><br><span class="line">except ValueError:</span><br><span class="line">    print(&quot;输入什么玩意儿，让你输入一个非负整数&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2023-11-6练习"><a href="#2023-11-6练习" class="headerlink" title="2023.11.6练习"></a>2023.11.6练习</h1><h2 id="问题1：-2"><a href="#问题1：-2" class="headerlink" title="问题1："></a>问题1：</h2><p>猜数字游戏</p>
<h2 id="要求：-4"><a href="#要求：-4" class="headerlink" title="要求："></a>要求：</h2><p>编写一个Python程序，实现一个简单的猜数字游戏。程序随机生成一个1到100之间的整数，然后要求玩家猜这个数字，直到玩家猜中为止。程序需要提供反馈，告诉玩家他们的猜测是太高还是太低。最后，当玩家猜中数字时，显示猜测次数和祝贺消息。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">def guess_num():</span><br><span class="line">   real_num = random.randint(1,100)</span><br><span class="line">   attempts = 0</span><br><span class="line"></span><br><span class="line">   while True:</span><br><span class="line">      user_num = int(input(&quot;请猜测一下目标数字为(在1-100间选择)：&quot;))</span><br><span class="line">      attempts += 1</span><br><span class="line"></span><br><span class="line">      if user_num &lt; real_num:</span><br><span class="line">         print(&quot;结果与猜测不符，有点小，请再试一次&quot;)</span><br><span class="line">      elif user_num &gt; real_num:</span><br><span class="line">         print(&quot;结果与猜测不符，有点大，请再试一次&quot;)</span><br><span class="line">      else:</span><br><span class="line">         print(f&quot;恭喜阁下猜中了！目标数字为&#123;real_num&#125;，与阁下猜测的&#123;user_num&#125;完全一致！您真是一个小天才！&quot;)</span><br><span class="line">         break</span><br><span class="line"></span><br><span class="line">guess_num()</span><br></pre></td></tr></table></figure></p>
<h2 id="问题2：-2"><a href="#问题2：-2" class="headerlink" title="问题2："></a>问题2：</h2><p>查找最大元素</p>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>编写一个Python函数，接受一个包含整数的列表作为参数，然后找到列表中的最大元素，并返回该最大元素的值。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def find_max_element(lst): # 初始化最大元素为列表的第一个元素</span><br><span class="line">    max_element = lst[0]</span><br><span class="line"></span><br><span class="line">    # 使用循环遍历列表中的每个元素</span><br><span class="line">    for num in lst:</span><br><span class="line">        # 如果当前元素比最大元素大，更新最大元素的值</span><br><span class="line">        if num &gt; max_element:</span><br><span class="line">            max_element = num</span><br><span class="line"></span><br><span class="line">    # 返回最大元素的值</span><br><span class="line">    return max_element</span><br><span class="line"></span><br><span class="line"># 示例使用</span><br><span class="line">numbers = [12, 45, 62, 88, 34, 98, 75]</span><br><span class="line">result = find_max_element(numbers)</span><br><span class="line">print(f&quot;列表中的最大元素是 &#123;result&#125;&quot;)</span><br></pre></td></tr></table></figure></p>
<h1 id="2023-11-12练习"><a href="#2023-11-12练习" class="headerlink" title="2023.11.12练习"></a>2023.11.12练习</h1><h2 id="问题1：简单的购物清单"><a href="#问题1：简单的购物清单" class="headerlink" title="问题1：简单的购物清单"></a>问题1：简单的购物清单</h2><h2 id="要求：-5"><a href="#要求：-5" class="headerlink" title="要求："></a>要求：</h2><ol>
<li>初始化一个空的购物清单。</li>
<li>提示用户选择操作：添加商品、显示购物清单或退出。</li>
<li>如果用户选择添加商品，程序应该提示用户输入商品名称和价格，然后将商品添加到购物清单。</li>
<li>如果用户选择显示购物清单，程序应该输出当前购物清单中的所有商品及其总价格。</li>
<li>如果用户选择退出，程序应该结束运行。</li>
<li>在每次循环后，再次显示操作选项。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def menu():</span><br><span class="line">   print(&quot;欢迎使用购物清单程序!\n操作选项：\n1. 添加商品\n2. 显示购物清单\n3. 退出&quot;)</span><br><span class="line"></span><br><span class="line">def add(shopping_list):</span><br><span class="line">   name = input(&quot;请输入商品的名称：&quot;)</span><br><span class="line">   price = input(&quot;请输入商品的价格：&quot;)</span><br><span class="line">   shopping_list[name] = price</span><br><span class="line">   print(f&quot;&#123;name&#125;已添加至购物车 \n &quot;)</span><br><span class="line"></span><br><span class="line">def display(shopping_list):</span><br><span class="line">   if not shopping_list:</span><br><span class="line">      print(&quot;购物车竟然是空的！再忙，也记得买点什么犒劳下自己&quot;)</span><br><span class="line">   else:</span><br><span class="line">      print(&quot;当前购物清单：&quot;)</span><br><span class="line">      for name, price in shopping_list.items():</span><br><span class="line">         print(f&quot; &#123;name&#125;: &#123;price&#125;&quot;)</span><br><span class="line">      total = sum(shopping_list.values())</span><br><span class="line">      print(f&quot;总价格为：&#123;total&#125; \n&quot;)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    shopping_list = &#123;&#125;</span><br><span class="line">    while True:</span><br><span class="line">        menu()</span><br><span class="line">        choice = input(&quot;请选择操作 (1/2/3): &quot;)</span><br><span class="line"></span><br><span class="line">        if choice == &#x27;1&#x27;:</span><br><span class="line">            add(shopping_list)</span><br><span class="line">        elif choice == &#x27;2&#x27;:</span><br><span class="line">            display(shopping_list)</span><br><span class="line">        elif choice == &#x27;3&#x27;:</span><br><span class="line">            print(&quot;退出也没有，摇一摇等下又见面了&quot;)</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;你在说什么？ \n&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>旅游-香港</title>
    <url>/2023/12/13/%E6%97%85%E6%B8%B8-%E9%A6%99%E6%B8%AF/</url>
    <content><![CDATA[<h2 id="2023-12-11-2023-12-12-独行香港"><a href="#2023-12-11-2023-12-12-独行香港" class="headerlink" title="2023.12.11-2023.12.12 独行香港"></a>2023.12.11-2023.12.12 独行香港</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>香港有着“东方之珠”的美称，这个名字我以前也只在书中、电视里和母亲的口中听闻，它的繁华和发展早就在深入我心。基于2019年事件和网络上对香港的负面评价，作为一名非粤语母语者，对于香港多少带有恐惧情绪，万般纠结后还是决定亲自去看看这座城市。恰逢考完试有空闲时间，收拾好行李买好票就出发前往独自香港，开启了我的两天一夜香港之旅！</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>提前准备好八达通或者支付宝的香港地铁卡(我强烈建议用八达通)</li>
<li>旅行时间短可在网上买境外流量包，时间长去便利店买33$的流量卡(50G+1000分钟电话，有效期1年)</li>
<li>换一些零钱，有的店只收现金</li>
<li>上下扶梯靠右站，上下楼靠左走</li>
<li>不要在公众场合抽烟</li>
<li>不要喂鸟类</li>
<li>过海关不要带违禁品，注意携带烟酒数量</li>
</ol>
<h3 id="角色栏"><a href="#角色栏" class="headerlink" title="角色栏"></a>角色栏</h3><ul>
<li>穿着：短袖、短裤、长外套、运动裤、运动鞋</li>
<li>移动方式：步行、地铁、公交、渡轮</li>
<li>证件：港澳通行证、身份证、交通卡、银行卡、过关小票、金巴小票</li>
<li>花费：1000+</li>
<li>其他：充电宝、数据线、转换头</li>
</ul>
<h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>从学校出发，要前往港珠澳大桥珠海关口，最快的方式是乘坐高铁抵达拱北口岸后打车。由于C7611车次临时停运，我只能乘坐C7617，加上打车的时间(直接坐出租车花了23，如果用打车软件会更便宜)近11点才抵达珠海关口。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/1.jpg?raw=true" alt="珠海关口"></p>
<p>海关内禁止拍照，我描述一下。从“往香港”的入口随指示牌扫描通行证，按指纹，然后往前走，根据指示票前往穿梭巴士等候站，在大厅记得取票(一定要取票，检票不能用电子的，要扫实体票上的二维码)。跟随人流排队上车，很快就能上车。中午11点左右出发，坐左侧无太阳可看珠海、深圳、香港的城景和反光的大海；右侧有太阳但是看到的海景比左边好看，靠近香港机场可以见到蓝绿的海和缆车。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/2.jpg?raw=true" alt="港珠澳大桥"></p>
<p>达到港珠澳大桥香港口岸后，随着人流过海关，下来在门口看到便利店可以在里面购买流量卡。出去之后可以选择搭乘巴士，巴士的价格和地点上面都有写。省钱小技巧：乘坐B5去欣澳站搭乘地铁前往想去的地方会便宜一些。若使用八达通，拍一下就可以上车了；使用支付宝则需要先切换左上角的地点至“中国香港”，后点击出行扫描二维码即可。到达欣澳后，我坐地铁去了深水埗吃饭，出地铁站走几步就看到了一家网红店“新香園 (堅記)” ，那时店里人挺多。一进门老板就热情的用普通话问我几位，我说1位后将我带进里面与两个老太太搭桌，拿着笔和纸问我吃什么。还好提前做了攻略，很快说出“冻奶茶和蛋牛治”，价钱小票和奶茶几乎同时放在我的桌子上，一个来回的功夫蛋牛治也好了，我拍了一张照后就狼吞虎咽的吃了起来。吃完拿着价钱小票去前台，收钱的老板不会讲普通话。“老細，AliPay————41蚊OK咗”，这是我在香港第一句粤语。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/3.jpg?raw=true" alt="冻奶茶和蛋牛治"></p>
<p>吃饱喝足在深水埗逛逛，又返回地铁站前往旺角站，去看看那些耳熟能详的站台和真实的香港。走在彌敦道上，来往的人络绎不绝，各种肤色的人穿梭在这条路上。大家都急急忙忙的奔向各自的目的地。汽车在中间车道上快速行驶着，双层的巴士来来往往，红色复古的出租车是香港的特色。道路两侧有着高耸入云的破旧大厦，有的是住宅，有的是办公楼。有时我会看到这些大厦的入口，银色的防盗门，里面漆黑一片，偶尔还有开门的大爷老态龙钟的坐着，与门外的繁华形成了强烈的反差。路上的人也走的很快，旅客、本地人都是如此，伴随着人声、车流声、信号灯机械的提示声，在这些高楼大厦下更有了压迫感。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/4.JPEG?raw=true" alt="彌敦道"></p>
<p>走到佐敦地铁站不远处，在彌敦道和柯士甸道交叉路口，我灵光一现想去历史博物馆看看。沿柯士甸道上走，这里远离了大部分的人群，走路也稍微变慢了些，鸽子扑棱着翅膀飞向路灯，四处观察着这座魔幻的城市。走到漆咸道南的十字路口，我惊讶的发现了香港理工大学，不过没有进去参观，只是远远的拍了张照就前往旁边的香港历史博物馆了。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/5.JPEG?raw=true" alt="香港理工大学"></p>
<p>博物馆没意思，可能是我没找对<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/6.JPEG?raw=true" alt="香港历史博物馆"></p>
<p>之后我又重新回到彌敦道，只为了打卡那座大厦————“重庆大厦”<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/7.JPEG?raw=true" alt="重庆大厦"></p>
<p>继续往前走，我去了李小龙铜像，很多外国人都在铜像前摆着与雕像一致的动作合影留恋。沿着星光大道一路观赏着维多利亚港的美景，那时正好是太阳落山时间，夕阳的余辉洒在这片寸土寸金的大地上显得更加的高雅。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/8.JPEG?raw=true" alt="维多利亚港"></p>
<p>路过K11时，外面摆放着Dior的圣诞树，浑身上下都释放着昂贵的气息，引的人们前去打卡拍照，合影留念。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/9.JPEG?raw=true" alt="Dior"></p>
<p>本来想去香港岛吃晚饭的，肚子实在太饿了，但是周边又没有什么好吃的，没办法，看到了麦当劳…谁来香港吃国际连锁快餐啊喂！我靠还真的好贵，而且味道没有特别的。这里有个小插曲，有个1.9m的白男似乎想续杯咖啡，前台的那个姐姐仰着头，义正言辞的说“NO”，似乎还有点生气，我有点害怕。巧的是，下一个取餐的是我，我说了句“雷猴”把小票递给她(我不会念数字)，拿着我的餐就跑，不敢有太多的接触，社恐本人了。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/0b3ff7ece70b03124e4f2da6561400a.jpg?raw=true" alt="M记"></p>
<p>吃完饭外面也天黑了，终于可以看到维港的夜景了，为了这个夜景我才选择留在香港一晚。真的非常漂亮，比我2010年第一次去上海时还要震撼。坐在天星轮渡上，我甚至忘记了多拍几张相，而是静静的欣赏这座城市，非常喜欢。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/10.JPEG?raw=true" alt="维港夜景"></p>
<p>乘坐渡轮到达中环码头，就可以看见香港摩天轮，买票加上车排队共花了近40分钟，20蚊上去转三圈。在摩天轮上看香港的夜景真的很美，也不贵，还能听旁边两个老外讲英语笑话。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/11.JPEG?raw=true" alt="香港摩天轮"></p>
<p>结束了Day1中计划的最后一个部分，我就要前往酒店了。决定步行前往，切身感受下香港岛的高级打工地，这里的人西装革履总是在打电话，神情严肃，走路飞快，但是人不多。在这里总是有种窒息感和压力，偶尔几天我觉得还挺舒服的，时间久了可能就…快靠近酒店时我还迷路了，Google map和高德都不准，没办法，我只能根据店名来判断，地图上的大厦名我根本找不到，好在最后还是找到了酒店。前台的小哥很好，我说普通话也很耐心的帮我办理手续，并且免费给我升级了房型。晚上10点半肚子饿了，跑到楼下711买吃的，附近有几家酒吧，不过不吵也不会觉得不安全。一个人住酒店莫名有些害怕，开了一晚上的灯睡觉，休息的还算不错。Day1就在睡梦中结束了。<br><img src="" alt="高级大床房"></p>
<h3 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h3><p>早上8点多才起床，收拾好东西下楼check out，前往附近一家很出名的车仔面吃早餐。这家店“车仔面之家”已经开了60多年了，本地人也很喜欢吃，他家的特点是“立食”，因为店小只能站着吃，而且只收现金。里面的阿婆不太听得懂普通话，我的“幼面”和“油面”不太听得清，很耐心给我指着哪个面。点了配料之后在纸上给我写“35$”，我点的是“小份幼面+鱼蛋+鱿鱼”，他家的鱿鱼和猪大肠很出名。出餐也很快，接过面放在桌子上吃了几口我就开始找钱，正好口袋里有个5$的硬币。把钱拿过去时阿婆不在，只有个煮面的靓仔，看着有点凶。我鼓足勇气说“雷猴”他马上微笑过来，看到我把钱放在柜台上说“唔该”，我又回去吃面了，真的好好吃啊。之后来了一个东南亚男人，那个阿婆英语说的也好好啊，那个男人的咖喱味英语我都有点听不懂。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/CRnall_20231212_084131779.jpg?raw=true" alt="早餐"></p>
<p>吃饱喝足来到下个目的地，也是我这次来香港的目的之一————办银行卡。我坐地铁前往汇丰银行北角分行，走过去的路上我不敢放慢脚步，生怕走慢了在银行前面犹豫而败北。进入银行，很庆幸里面没什么人，我找前台的姐姐问了这里可不可以开户，姐姐很耐心让我取个号等待。一分钟不到那个姐姐就领着我站在大堂的柜台上办理了。简单的问了我为什么来香港办理银行卡，我答了海淘和投资，姐姐没说什么，让我拿通行证、身份证、过关小票给她，填写信息就好，忙前忙后的，我就负责手机注册了。问了我现在有没有投资，我说有，基金，拿给姐姐看，不知道她看到我的白酒亏6个点是什么心情。旁边另外个姐姐过来问她“佢點解開卡？”“海淘”，以为我听不懂哈哈哈哈。当场下卡，开完就跑。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/12.jpg?raw=true" alt="汇丰one"></p>
<p>吃完去太平山，坐的小巴，想体验一下“亡命小巴”的感觉，亡命小巴，现在出发！那个山是真的高，转了好久才到<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/CRnall_20231212_114109540.jpg?raw=true" alt="太平山"></p>
<p>拍完下山去堅尼地城，本来要去熟食区买的，不会点餐，又跑出来了，去其他店看，不是人多就是好贵，之后去了大家樂，虽然这个也是连锁快餐，不过还是很有香港味道的<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/CRnall_20231212_130318868.jpg?raw=true" alt="大家樂"></p>
<p>吃饱了就去香港大学了，买了纪念品HKU小熊。另外港大也真的很漂亮，虽然有点小，但是里面的学生给我一种精神气让我莫名有点畏惧，可能是社恐怕被同龄人问路吧hhh。<br><img src="https://github.com/Aurora7july/files/blob/main/%E7%85%A7%E7%89%87/%E9%A6%99%E6%B8%AF%E4%B9%8B%E6%97%85/CRnall_20231212_140430269.jpg?raw=true" alt="HKU"></p>
<p>之后的时间我在港大坐着发呆，下午4点多返回九龙，去找汇丰的ATM机试图改卡的密码，失败，回去了。旅途结束了。</p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo命令</title>
    <url>/2023/07/06/hexo%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><p>使用以下命令后新文章将在博客目录下的<code>/source/_posts/</code>文件夹下<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>
<p>举个例子，我今天想要创建一个hexo命令的文章，那我需要在<code>git bash here</code>中输入<code>hexo new &quot;hexo命令&quot;</code>即可创建新的文章，然后结合另一篇文章<a href="https://aurora7july.github.io/2022/09/03/Markdown%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/">Markdown常见命令</a>使用即可</p>
<h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>以下简写代码和完整代码都可以使用</p>
<p>这是清理缓存：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure></p>
<p>这是本地预览：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo s (完整代码为$ hexo server)</span><br></pre></td></tr></table></figure><br>这时会生成一个<code>http://localhost:4000/</code>网址，它相当于一个草稿，让你先看看要发布的文章有没有什么问题</p>
<p>$ hexo s -p 5000<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果在运行hexo s后出现错误，无法访问等，可能是因为4000被占用了，所以我们可以修改至5000就可以预览我们修改的内容了</span><br></pre></td></tr></table></figure></p>
<p>这是生成静态文件：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo g (完整代码为$ hexo generate)</span><br></pre></td></tr></table></figure></p>
<p>这是将本地文件上传github等git仓库上<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo d (完整代码为$hexo deploy)</span><br></pre></td></tr></table></figure></p>
<p>我通常写完文章后会喜欢使用“一键三连”上传<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><br>如果在上传过程中出现错误，先检查是不是代码打错了。如果不是代码问题，就是网络问题。这个全靠运气了，如果不行重启或者晚一点再上传。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>马克思主义原理期末复习</title>
    <url>/2022/12/07/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%8E%9F%E7%90%86%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>正确率应该在85%以上，只有选择题</p>
<p>尽量使用网页打开文件，实在打不开点击<a href="https://github.com/Aurora7july/Files.github.io/blob/main/%E7%AC%94%E8%AE%B0PDF/%E9%A9%AC%E5%8E%9F%E5%A4%8D%E4%B9%A0.pdf">备份</a>试试看。</p>


	<div class="row">
    <embed src="/pdf/马原复习.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>量子力学</title>
    <url>/2022/10/25/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="94f1842aaf74c037b57870cae1da197f171bb4b00e77b3f9584c0963687bf7f5">bd25ed9264b080267271e137e33d0ce118960a041ac35a180347d4bc9710c7dc8ffd3a92c3998a037c2c77660c8510c08d0e2e16e0f79962dcd4fbd46c6468275b6104b5c5f163549a3ae237cf8441ca48a44ed76fdd12e2177ed6e20f330376316022f5b9e400d973edb71686f85cc1a3c589105c6b6cfd8c48832d45e050493b6807a91327cda5599b992e5dd6dc6f46f8d90531553790defaf3419cadf640df5a9272f92630053391aab2f04f0e941c499d263d05eeda6f52865a7e541d4d7885b6a959a16727e2629de8e566660b607e555868f581663afd7837d07944bae3bfd73eecd4b7fd29c02835e5c6734e010dc2ea7ad235e53ada6cf5576f88fe24b567fdb0d7e8b25ce1804987078c893fbb9903058ad1bed84279d51c7861b5ab7618e9959587689e369f947ce5cffa86838ae7e3683b3ab0f6351a0eb16fc46c786ff9bf10ec6738560d6f52ce1058b634397a089386fa6ceae2542f13175a8447a244dc9952cc222f832b88b76e65cb94ab73017a45c6cc9a2f86c658a782e0138a8e813f2ba0b73a402aa948c8fd88d5db4f01f07bda2b5e28dcb6cb926650e6a305aaaa025179c5b68b54306f0bbd6b8b07b527cb2d6fb35af9b0f43b4cb3715e04233547974bc63dd700da62214f2421a6024c9b6de40f01ac4629417ba21edeb0c46bab3311025178f60e4e626cc0b1b0c7ad7e9be839000b8e25805e17e650c81d441ba6830cf413918477bf16c82877fb7aa760a91e03a19c3c8cf997482699036deb6a50a96716aaa584eda645e7c284e8b66552d74403fea9289fc54dc995d412f1b58f31d42184227d05c761b4f65fecf9bb9624360ca03bda383852b787ef5182c61781e73b782c7008389cb8e288096f9ac9f54e4fcd4d2df2d17e9d1becc14b7572a131a28268120c310261e60aef3d30463f9bdb31691d2bb85ab403858ecac36f804ed97d49985d6bb6912a845133f0b94e95546172987aa9655a98b8c5722d23dd7a7a4cbd766a9da0c62fa368acfdd06795d7caad9c6898878535581480c629b2c99041a61c9a138ee0ff0dd0e2005d1f915f1f725400cace6f49ffc087ab028c7a794981358a4dedc466789e1ccaa0e1d45e1d51bcb37c4c25a38c713e4ce0fa3e84a8b2a5e37ade4bc48562c814e78707aca69aff877f43b63c6598238189d531e56d91cf3accba3951b96c7d2fdb8916bb29195e684449bd199cda2e7c8833cce8f31dfdb11c3ae1d0120d0aaf015b289eb205c0aa6bc1596e0e3ab8cb992c9fdcb04988e4234877acdacd92c99f4644b73063ce5d189f7de6d66aba9e9a60231689a604e90bea76b52dff5002a2c010f4bb7f8f2d291b0c45832d5e516fdc816e9454655af3d106d50688054bad89af3ca7da040dca23c6b2fa570a92d12d8288321ad913d1c6d1ca4e3a7efdd34230b8b8f7d6a30b46197e0906e20181bf938e2552135908c364d1c8b199c7d07fa0699e131bd26bf3b9886b4d3fa715aedb65004969760257328caf67aa251081a77174dd45eb03aba4b50c18c26bd4837ea082798483b45a8f6007bc154c9075e37710466492fdb90770ccd1eff1d9c458198ff518fe77268c021957f9b39ca5bb59085a4993b3ab939aaa12e63c0cdc9ff7f21e03d4a75e62fd2db17b764d1f45ee1c68f841730bf33685bf95ed4deb7838643f99e28b91aaa18099f2d06d86eed596bb75c83c7124fb96c3c9b6fa6294a9cfc439bbcef3fbad22eff0eb28f1a6c0e551fc7be26155ad3066d772dc7c50d1ca9fe7654cf046b399f28119c4fcf7da3e2e1b0da851a338cba01f56377faac6407bc9526cdf5bc13d2d7ca4417bcca6504a9824e2cd38698d00e344fc07b70d61a3b7cc68e5195971a0f1f6c17dc0610e1df35bb227a0cc1571fc9a646115b64f24b4e969edd2643ca1c5c9ef882bd8970ebf61f27b5798d9ef367a5658e4e0ac848723b61c3e4a0e6ef1594eaeccf698cdaa47e6ae3a81c3ce8486fa86fe41cb89b4c4bcacf36cac50774d6a56524b7aee25e5a9d14afb0cb0fc5a4840b6d7358a0cfa62c0267eae6980f370acc397cce90e27138efb9b449aa02c08c3f387493d2d491c2571dd163a02cc365a8ad06e4470bd9cc3b2295123f4ebc6ae0c09876b4d742a4ec4418eaf565365e5f17ec246592c18f1a00c43a5862074c26db30932df2bd5a66d3d0b1482f4d4b762d1218e93cb47363915de9163d413b5409057b4b62b946981a51937be83db164d8e96c32bfeb6c696093409ebf9f13c5c1e674d4adfaaeb09ca420fcf7435d796da31258cd91844fc2cd0eb1823c272881b593fb0c4a329277e89ed6728437343527aaaec13504a706335909a4ccbea585b6d66e2fcc450c8c200543ca8642e543fe3aa81162b6d0907ca59cfd47226650f585b5a79921ea25658e4246a76b96989b4631a4ba35c4fc1368340afb05ee2100a428989c43eadea661b3eab87fca30eb52b3905bf7bc59c9d5248631c151bd740e6c1d58288376d91f8260ce5c493c7a63187037136024b213dbe098bcfd19078d40061ffdc2c3b255c45ab9f8c60a1c02be8f5c77a83f07a415ddea570a0c0e50119733481b4559fe4cabe03f9bb65c9066f16c2ae732a1c895a83f84ae04bcb542fcb51d0c0fa3f6c706daffa6bf69927deb9db01281e7d9d6804cb8374cc3706da33c8bd904b56fac3f339c32d68d3108a897a2e0251d0528d1cf92e27caf94ee816eb975ecc08bbf865b4cbda32b3c594523f3786aebbb1d89cbf102f636d147f53b495c8faaec229ab816387a6bedb9890b984a021bb43c0da2035f7eb05258d3515a9456f5906801f95f67be673669ef7c4a1177f5c7c248874f76b22ed1489219a5762146439f0be4c613b732d15affe813e144a9c3d8e4105ff5a0d5b6ed879124bfd7449b269d4bd0799fff7b15f894ee141023792e30ac518059cb35b99f61f465fb6c7a18af2d3eb3cdc0b516faf04dc07ac7f8d493e237c72683ab14549819c8bc20edafd5d0dc392f4d139585473b99a725527237f82ce51b319afda48eecc0dea7548f7c292a58a54b1eb9a7ba9d21b05720f53df000f236a57a77fe42e4bb0d469d3a0e9f6be4f7147440faceeef0f62027396a876083b6b483149127277af717fda9ba172a11a68ae23ff0fac48c6c20e172a1e8c02f6c3a06688ee5e80e6b0d943f7f22c53ae7c00121480725c53cfdb4abdbf42d35bb341f69dbc042a3a2c4547c4a564a4fc91cea94c71e6b469f9b6bd94b1205c3e6efe6f77685ef6472a60daa59630b06670c0297395ff0b1a2d32889af7bc11f0c603b3f43cc24e31d76aaab779e14f8fd6da8ba8314f61a1a1712c0e4aa9e35d44f610fb065db0fcd36a1cf5970641a80fe95b5bf1116a621b3320e4c4b460746187f7fe8a43415f14584464e0f037adfe081d1b70b33576397c4c4cce450fa3be2fa97a4f1780beb0c91524c2cdaad8216b350bef7bc4943037b84be1c0e3a23d0964a86b027a4a3e6236f9d3e86570802858d54d487655378fd824194344d1252462118b4d6b596e24aa16bdbc99cefac54b91c40398f8b69715914e4cf43464b4b8a35eb949d2093d07a48d63bf731c9dde1ba6f5a51ee7b0866eb1344b51180b7d9a79e0f479a5d3c9d43ff950e77997f15453703b9c21d7429af094f722c5e9b99f3bc916971988fbe244716b0f91854762b0bce64c14e00e46765a49afcb70f5cafb646a780a4043d0ce6cadc99c733fd4cf179294b4fcabfcb849c495f520c52218f5d073bbdf7f3a6eeb6398f624703698bebbb24b7f24f45ca53ba351bbabac6ab97967e5230aa3b6f6f27ad6d97005dcc467f2dcf6fea073b9a501590c4d378976e6dec157cbe3649a536fdc46563ea7b5ad0bc19bd99ad2ffcd57605bb44342603c6ebb65de4ed075b467591a70a3c1affd24855864c80db3dd6eb8ee0b5740bb5d9303f2aa13c6768bced4bb1bcead733fe768a4a2fbda30a940f195deb114c48352703e72a511d3cd5d99a164f057ae76511275b1e846c0026db12aeb71ae6a7211579f04aaf91f74f215e32e4e3b680cf04488dc6d5f39d602a443374e249fd1bb88e6ef7cb35fee86da4767e4dd29465637a6efadcff7fee7ef067e4215301c4e86afb79bf103423e4642a73c060688de4153913b0aa0dba3dbc45db1301fdba4839913c7ffb761eef023157ecd603b47443282394e13c47e5fd7e1b8f53d4c7509736cdb1386e9843fc708428d8db1b71564a7171227ea0c9fd2e352f3e5a26e7a456e79b30368c38174166ae64b055e2007dd830ebc7ca409ac57b5ff0d7209d5d25efcf0e72836e0e865d90cfdbfcbbb86cbac5961e14e4ea1ac3f2f26feef3af51927a616951c6c0f327dad1a04ba8a38ca41982f396aeed0b8af54fad6c8a4b1b3fa708e160586807c726efb110bfc0bda8133c7125c0f99db722b9c84007354c99fedf22f5e5278d2faf892fe2077fef9207c5a0fc4b05f9027737cd3d187ad5425cf69368a89c0eac89858ea35526d16edbdcee5be30ee2035a6681efef9eb5c9f1984d36f093391934c4f216a9ce1e6da813a47ac9d49b5b3ff11031fe96a318958231f4882500df535c249b34a32cd720c9bff7aa53b4ec49a6639ae62088abe5327ba60c1a057c7c04aa2feb87e0bf79d5bfc61b41067eefcd77580ec8734c9ad5ddedaaa7aa1bf6c6ac1fa458669ec21632da94f7540909c5292e24051f488266ca53cda03a3ae01b73c5cd65e5e1ebca5982853ce062acf06c6de4bf284ffc039068ab3028a9027228d13b6a32a7cab74a1c74090bc692317880eaa9c34eac455ee5d9953c686ff683458dc03828519cd1f67a89c653346bbc3f1c9bd752155f5c99bdba3c26d967bafa526a5d1d085eb3c04179d443f905eb2069a263af11385d0e599c238481e93f90723cb2db4539c85cf579959b95608b820ac73baeff9bb2db7cded0591082fa36267d377955c24118a6a3ac26cdd94bf06d884bfe70fb8bec6ba51fb16803a085c3dddd4ac808c384389693f0dc8540c6946884af366a2fdf125bdd8654dbc09b325cd9a8a8dbb5f88eca7b93666ba3646a94653e66e692c84cffdf3e6e541f812dbab433944e2155c19b078794e7e8293d08c21809e639d2b5993d6ac197e90662922ecf08b4669d6ed2a8d4e1aceb611fd1cf2f0b903ce9f5db7b2093655403aa5e2e17cfa0b25fff8fb81ae285dc9678d8f8efb9a50d19ac081a29d02769d761d1b75a0e415c22b07343fe280759f58723f47d5bc2aed6af179568e91f5325b6fafe6bfe51d979e3fe4ad7d8b1728f0458dbec65dadf58769d8344e4471abea45aea42e45cb61daed7d3746e6a5128176da08c2d27852a3b290256cb4defcef92962850d492a567e79d11b6b33b02c72656e882d763785fce9d5e1f6dd644d4a42b4a8da091dad83029dc743e8fa942353760bee40a6e8ce189970bf05f290529d30917abe8f8d42337e392d247fd0fae800f516d24f970fc436a9cc09da9a16461c2e6cd34595be1b8fd15c5406b16bbe3a6ecd724c66eb73bde89685261fca26072620f621e8d0d42ed31d41a6c09eb3bafa0d67bdd3f8166aeb4bcd1c80fdd6f8b88c143a08001595a550551a65217b1e537c4ad3f4401f533f7dbda65612247cd56a9510c3b99bd099ecc5fd45378d9c56e5296f6ff60a8bd4eb822759cbf62f37ae635ba2f824e997f8d5e55501ed517b51d98434182bdc66444012e0cecc365e612ef5e9d6cc749e5dec5255929e34f9e7a3a92680ff50d7cbd066ae7f831e017d255276fe7d6e684ff038a0dd3df84ffe1c615e0da3abcef65ab3f46694385940c0ff8c42167365d371b181f9976d301f66f3512c1dfd65af198539efe4664579dc2c42b153615afc42d6af8e3071e4d76e13cf1ed9fb6620a97137b212fcd3c8797c4858192b8cce6160fe06499509b8fbf78d9ca204bd3105590b46d151639b9233f4b23d95e1c00413d6343667d0610fc64419725125afc5028f7f52bcd44c49b79835a599553c00dcc51df5816befc94ce17e29510b7c7c77c28f5d7af8f2a4167afeaf27f6e4e621ac0d56dac973c43ea201a7791003f1438e69173003bc9c210befac344c00a946275c29be4549d02777ea0275a126aabae93cc17afd843ad28a417ab68027fa201f0e1a5c10fb5ebc9ed894c4973433b855fb8dce46535e573b78e870df7d2eaee0a0636340550ad90f7550dc84b9c2a28a1b618b97fb4c48204cde999c0f11e4a26101e42962d245aa567ba2c74141f221c4f9b3371000b0b62e333deefab3e16831f9274b8bfa9394a5d9db56d0965be8d2fbbc7d14e2c8bfcd3910c9ca4abe34d42e362e0e7f5b06ad5d8a66b569b4fa8cfd9ca2d3ee2bb493cf0c36ba5075ae2a70540e6bdf3c3e2d8efb9f1509866f79a2ffda6bacb59d4940f5b820791d918477c609486904cbfe7ca9d3f5f666de821c66fe97bc100440e1bc7fde7e34000e56dba4a3ad703687bbdb31e963def36c5d6d970b6bf248d938d7b4f7ca1bb71c885d5ccee86eb68f3d98649be0e8dfe2864dceec68d35fc32cd7425a94d06cf1ce95df51dacf38af3a784b2f8e4727e2b62eb8416a1bfbffa1ac40755156bc65dbe5d6758a9f2219b5d716382997261d7eda19baa85e6acceadfad5f7f2b3c5d366f5bd247a2fa4a483898dd6e2d3a73a5a535459090a31867ae3d9b33292809c7a39d7bc85351a150bbc09f8ae5aefc3406125680140ddcfaae77f2ae8098991eaf654b796d100e7596daef45d2ae35b6aecacb886112dbf2a8994aed555ca194a7881501d67b0c88ae6189bb287e9810210d5e70a09c36029d7b4d13f4384bc4a0905cb82283bade0bfa1f45e38fad5b3d2e100291ffc2802587876</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">测试加密，这里的密码是：test</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
